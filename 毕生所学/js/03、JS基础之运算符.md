# 运算符

## 算术运算符

`加(+) 减(-) 乘(*) 除(/) 取余(%) 乘方(**)`

```js
// 加法运算
let a = 1
let b = a + 2 // 此时b等于3

// 减、乘、除同理
```

重点说下取余运算

取余运算即是字面含义，取除运算的余数，有时也叫模运算

```js
// 例如：5 除以 3  商为1   余数为2
let a = 5 % 3 // 此时a存储的就是5除以3的余数2

let b = 6 % 2 // 此时能整除，所以余数为0，则b的值为0

// 小模大的余数
// 例如：3 除以 5，因为被除数比除数小，所以此时商为0，余数为3
let c = 3 % 5 // 此时 c = 0

let d = 2 % 10 // d = 0
// 所以：小值对大值取余运算时，余数为小值
```

接着来看乘方运算，乘方运算就是计算某个数的`n`次方的结果

```js
// 例如：计算5的平方
let a = 5 ** 2 // 等同于 a = 5 * 5 ==>  a = 25

let b = 4 ** 4 // b = 256

let c = 2 ** 3 // c = 8
```

## 赋值运算符

`等于(=) 加等于(+=) 减等于(-=) 乘等于(*=) 除等于(/=) 取余等于(%=) 乘方等于(**=)`

看起来虽然多，但是比较比较容易理解

> 通常看到等号，要先计算等号右边

```js
// 等于 以下两种都是等于运算，简单来说 就是对变量赋值
let a = 1 
let b = 1 + 3

// 后续的带了运算符的都是同一个原理
// 例如: +=
let a = 1
a += 1 // 此时a=2，因为a += 1等价于 a = a + 1

// 其他同理
```

比较特殊的两个赋值运算符`自增1(++)、自减1(--)`

```js
let a = 1
a++ // 此时a = 2，因为a的自增1运算，可以理解为 a += 1，也就是 a = a + 1

// 同理
let b = 3
b-- // 此时b = 2，因为b的自减1运算，可以理解为 b -= 1，也就是 b = b - 1
```

所以自增和自减，是在自身原始值的基础上，进行增1或者减1计算，并且会改变自身的值，有赋值运算的效果

需要注意的是，自增和自减还有一些需要注意的地方，以自增为例

```js
let a = 1

let b = a++ // 请注意，此时 b = 1
```

原因是自增和自减，有两种情况，一种为后置自增或后置自减，另外一种为前置自增和前置自减，写法就是符号写在后面和前面的区别：前置自增：`++a`、后置自增：`a++`，自减同理。

接下来我们来看下上述为何b=1，而不是2，原因是**后置自增和后置自减参与其他运算时，是先将原始值完整参与其他运算后，才进行自增；而前置自增和前置自减，是先将原始值自增或自减后，才参与其他运算。**有一个先后顺序的问题。

```js
let a = 1

let b = a++ // 此时 b = 1，a = 2
```

是因为这里有一个自增运算，同时还有一个赋值的等于运算，而a的自增是后置的，所以此处程序先将a的原始值1参与其他运算（此处是赋值运算）后才会自增，所以b接收到的是原始值1，而后，a自增为2。所以结果为：`b=1  a=2`，自增运算同理。

```js
let a = 1
let b = ++a // a = 2  b = 2
```

根据上述原理，此时a的前置自增，会先进行自增，后参与赋值运算，所以`a=2  b=2`

> 赋值运算符是非常简单的运算符，唯一需要关注的是自增和自减的情况。自增和自增还有一个特殊的功能，后一个章节讲解

## 比较运算符

`大于(>)、小于(<)、相等(==)、不相等(！=)、全等(===)、不全等(!==)、大于等于(>=)、小于等于(<=)`

比较运算符的结算结果，永远都是一个布尔值，条件成立为`true`，不成立为`false`

```js
let a = 2 > 1 	// a = true
let b = -5 > 1 	// b = false
```

需要注意的是相等和全等的区别（不相等和不全等同理）

相等判断运算时，如果两个运算数类型不相同时，会先转换为同一个类型，再进行比较，如果相等则结果为`true`，反之`false`，而不全等运算时，如果两个运算数类型不相同，则立刻返回`false`，不进行任何类型转换，如果类型相同，则正常比较，根据结果返回值。

```js
let a = 1 == "1"	// 请注意，第一个运算数是数字1，第二个则是字符串1
// 此时 a = true，由于此时是相等比较，所以会将字符串1转换为数字后进行比较。

let b = 1 === "1" // b = false
// 此时，由于两个数类型不同，所以全等运算时，直接返回false

// 不相等和不全等同理
```

字符串再比较大小时，是按位比较各自的编码。`"3">"20"`得到`true`

对象在做相等判断时，比较的是内存地址。

关于不同类型的值进行比较运算时，类型的转换规则参考下表：

| 值                       | 字符串操作环境            | 数字运算环境             | 逻辑运算环境 | 对象操作环境 |
| :----------------------- | :------------------------ | :----------------------- | :----------- | :----------- |
| undefined                | "undefined"               | NaN                      | false        | Error        |
| null                     | "null"                    | 0                        | false        | Error        |
| 非空字符串               | 不转换                    | 字符串对应的数字值       | True         |              |
| 空字符串                 | 不转换                    | 0                        | false        | String       |
| 0                        | "0"                       | 不转换                   | false        | Number       |
| NaN                      | "NaN"                     | 不转换                   | false        | Number       |
| Infinity                 | "Infinity"                | 不转换                   | true         | Number       |
| Number.POSITIVE_INFINITY | "Infinity"                | 不转换                   | true         | Number       |
| Number.NEGATIVE_INFINITY | "-Infinity"               | 不转换                   | true         | Number       |
| Number.MAX_VALUE         | "1.7976931348623157e+308" | 不转换                   | true         | Number       |
| Number.MIN_VALUE         | "5e-324"                  | 不转换                   | true         | Number       |
| 其他所有数字             | "数字的字符串值"          | 不转换                   | true         | Number       |
| true                     | "true"                    | 1                        | 不转换       | Boolean      |
| false                    | "false"                   | 0                        | 不转换       | Boolean      |
| 对象                     | toString()                | value()或toString()或NaN | true         | 不转换       |
| Symbol                   | toString()                | Error                    | true         | Symbol       |
| BigInt                   | toString()                | 不转换                   | 除0n都是true | BigInt       |

## 逻辑运算符

`与(&&)、或(||)、非(!)`

> 与运算和或运算可以理解为一个管道

与是和的意思，`true`能通过，`false`不通过

或就是或者, `false`通过，`true`不通过

非也叫取反。

逻辑运算符在运算时，会在计算时，**临时**将运算数转换为布尔值。

```js
let a = 1

let b = 2

let c = a && b // 此时 c = 2
```

与运算时，a被转为布尔值`true`，根据与运算符的特性，`true`通过了，所以取到右边的值。c就等于右边的值2

```js
let a = 0

let b = 2

let c = a && b // c = 0
```

此时a转为布尔值`false`，`false`不能通过`&&`，所以停下来了，就取到了a的值，所以c等于0

或运算跟与运算则行为相反

关于各种值转为布尔值的情况，记住以下几个值即可：

JS中所有的值只有如下6个值可以转为`false`，除了这6个值，其他的都是转为`true`

1. 数字：`NaN`
2. 空指针：`null`
3. 未定义：`undefined`
4. 数字：`0`
5. 布尔值：`false`
6. 空字符串：`“”`



非运算是将运算符之后的值临时转为布尔值后，取其相反值

```js
let a = 1

let b = !a // b = false
```

a是数字1，转为布尔值为`true`，所以相反值为`false`，则`b = false`

```js
let a = 0

let b = !a // b = true
```

```js
let a = ""

let b = !a // b = true
```

```js
let a = "JavaScript真是太简单了"

let b = !a // b = false
```

## 6. 运算符优先级

[运算符优先级](https://baike.baidu.com/item/运算符优先级/4752611?fr=aladdin)

## 拓展知识（不用掌握）

### 位运算

位运算直接对内存中表示数据的位进行操作，所以运算效率是最高的。

位运算时会将数值转换为32位整型来进行运算，所以位运算遇到小数时，直接处理掉小数部分当成整数来运算。并且*要是一个数的二进制表示超过32位，或者运算完后超过32位，那么就会出问题。所以不是所有的情况都适用位运算*。

32位中，前31位表示数值，第32位表示符号，例如：**3** 的32位表示为：`00000000 00000000 00000000 00000011`。（PS：短除法求二进制）。

负数会以**二进制补码**的形式来表示，规则是：

```js
//以 -3 为例子

//第一步：取负数对应的正数的二进制码，例子中取 3 的二进制码
00000000 00000000 00000000 00000011 //3的二进制码

//第二步：取得到的二进制码的反码，0变1  1变0
11111111 11111111 11111111 11111100 //二进制反码

//第三步：反码加1
11111111 11111111 11111111 11111101 //得到-3的二进制表示
```

位运算操作符：按位非`~` 、按位与`&`、按位或`|`、按位异或`^`、左移`<<`、无符号右移`>>>`、有符号右移`>>`。

- **~ 按位非**

每一位取反，例：

```js
let a = 12;
let b = ~a;

// 12的二进制表示：     00000000 00000000 00000000 00001100
// 按位非得到最终结果： 11111111 11111111 11111111 11110011  

//因为 第32位是1，代表负数，那这个负数是多少呢？按照上面的办法我们可以反推回来：
//负数码减-1：         11111111 11111111 11111111 11110010
//结果取反码：         00000000 00000000 00000000 00001101
//表示的正数是：13，所以该负数为  -13

alert(b); //验证一下
```

所以按位非的结果为 该数负数减1， `~12 === -13` `~-5 === 4`

- **& 按位与**

与是两个数之间的操作，两个数每一位的值 1 1 得1 1 0得0 0 1得0 0 0得0，例：

```js
let a = 11 & 4;

//11的二进制  00000000 00000000 00000000 00001011
//4 的二进制  00000000 00000000 00000000 00000100
//按位与      00000000 00000000 00000000 00000000
//结果为 0

alert( a ); //验证一下
```

- **| 按位或 ^ 按位异或**

这就和上面一个道理了，或都应该能理解 11得1 10得1 01得1 00得0，

异或：11得0 10得1 01得1 00得0

- **<< 左移**

二进制码左移几位，右边的空位补0

```js
let a = 4 << 2;

//4的二进制码： 00000000 00000000 00000000 00000100
//左移2位：  00 00000000 00000000 00000000 000100    //左边超过32的就不用管了，右边少于8位的补0    
//得到：        00000000 00000000 00000000 00010000  // 16

alert(a); //验证一下
```

左移是*不会改变符号位*的，相当于原来的数乘以 2的几次方。

- **>>> 无符号右移 >> 有符号右移**

有符号右移：不动符号位，二进制码右移，左侧补0，原理和上述一样。

无符号右移：移动所有位包括符号位，整体右移，左侧补0，所以如果负数进行无符号右移，会得到一个很蛋疼的数。

- 位运算的运用

左移右移来进行相对于 2的乘方 运算。

强制取整，位运算直接会舍弃小数，例如：`let a = 12.12 | 0;`，直接舍弃小数位，并且或上0不会影响整数位。

判断奇偶，奇数 & 1 一定是 1 偶数 & 1一定是 0

……
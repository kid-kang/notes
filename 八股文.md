# HTML

## H5新特性

1. 语义化标签：header，nav，footer，aside，article
   1. 优点：增强了可读性，便于团队的开发与维护。
2. 媒体标签：
   1. 音频  `<audio src='' controls autoplay loop='true' />`
   2. 视频 `<video src='' poster='' controls />`
3. 表单：
   1. 新增一些表单控件：color ，time ，date ，range ，email ，url 
   2. 新增表单属性：placeholder ，autofocus ，required
   3. 新增表单事件：oninput输入框内容发生变化都会触发此事件，oninvalid 验证不通过时触发此事件
4. DOM查询操作：
   1. document.querySelector()或者是document.querySelectorAll()
5. web储存:
   1. 新增两种储存方式：localStorage ，sessionStorage 

## src和href的区别

src(资源同步执行):

- 表示对资源的引用，它指向的内容将会嵌入到文档中当前标签所在位置。浏览器在解析src时会暂停其他资源的下载和处理。这也是为什么将js 脚本放在底部而不是头部。 

href(资源建立链接):

- 超文本应用，指向网络资源所在位置，建立当前文档之间的链接。在加载它时浏览器不会停下来对该文档处理，而是继续往下走

## script标签中defer和async的区别

- defer 和 async属性都是去异步加载外部的JS脚本文件，它们都不会阻塞页面的解析，其区别如下：
- async 是在解析完成之后，立即异步加载，加载好后立即执行，多个带async属性的标签，**不能保证加载的顺序**；
- defer 是在解析完成之后，立即异步加载。先等 DOM 树构建好，最后再执行。多个带defer属性的标签，**按照顺序执行。**

##  常⽤的meta标签有哪些

- meta 标签由 `name` 和 `content`和`charset` 属性定义，用来**描述网页文档的属性**。
- `charset`用来描述HTML文档的编码类型：`<meta charset="UTF-8">`
- `keywords`页面关键词：           ` <meta name="keywords" content="今日头条" />`
- `description`页面描述：          `<meta name="description" content="页面描述内容" />`
- `viewport`适配移动端，可以控制视口的大小和比例：`<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=yes">`

##  行内、块级元素的区别

- 行内元素有：`a i span img input`；设置宽高无效除img，前后无换行，margin只有水平方向有效。padding无效。
- 块级元素有：`div ul ol li dl dt dd h1 h2 h3 h4 h5 h6 p`；前后都有换行符，能设置宽高，margin ，padding垂直水平都有效。
- 空元素：`<br>`、`<hr>`

## **iframe** 

- 优点：1 可实现跨子域通信，2 用来加载速度较慢的内容（如广告）
- 缺点：iframe 会阻塞主页面的 onload 事件,2 无法被一些搜索引擎索识别  3 产生很多页面，不容易管理

# CSS

## CSS3新特性

圆角、盒子阴影、渐变、过渡、动画、3D、旋转缩放等

## CSS选择器及其优先级

!important > 行内样式>ID选择器 > 类选择器 > 标签 > 通配符 

## 隐藏元素的方法及区别

1. **display: none**：不占据空间，会引起回流与重绘，不能触发元素绑定的事件，没有过渡效果
2. **visibility: hidden**：占据空间，只会引起重绘，不会引起回流，不能触发元素绑定的事件，没有过渡效果
3. **opacity: 0**：占据空间，只会引起重绘，不会引起回流，可以触发元素绑定的事件，有过渡效果
4. **position: absolute：**有过渡效果

## link和@import的区别

link异步；@import同步加载；

## Flex布局

- 以下属性设置在父级**容器上**：
  - flex-direction属性决定主轴的方向
  - flex-wrap可选择换行
  - justify-content属性定义了项目在主轴上的对齐方式。
  - align-items属性定义项目在交叉轴上如何对齐
- 以下属性设置在**项目上**：
  - flex-grow属性定义项目的放大比例，默认为0
  - flex-shrink属性定义了项目的缩小比例，默认为1
  - flex-basis  给元素设定在主轴上的大小，默认auto
  - flex属性是以上3个的简写。flex:1 表示 flex: 1 1 auto
  - order属性定义项目的排列顺序。数值越小，排列越靠前

## Grid布局（[详解文档](https://blog.csdn.net/leilei__66/article/details/122360901)）

- 以下属性设置在父级**容器上**：

  - grid-template-columns 定义列

  - grid-template-row 定义行

  - grid-template-areas 

    名字相同表示在一个区域（.表示不利用的区域），写项目属性grid-area的时候会用到

  - grid-gap:0px 0px 属性定义行列之间的间距

  - place-items:center 属性定义单元格内的布局

- 以下属性设置在**项目上**：

  - grid-column: 1 / 3; 描述该项占前2列
  - grid-row 同理
  - grid-area 定义所在的区域

## BFC

BFC可以理解为一个独立的容器，在这个容器中元素按照一定规则进行布局，BFC中的元素布局不受外部影响。BFC可以用来清除浮动，还可以将两个元素变为两个BFC，就解决了margin重叠的问题。

**创建BFC的条件**：

- 根元素：body根元素就是一个BFC；
- 元素设置浮动：float 除 none 以外的值；
- 元素设置绝对定位：position (absolute、fixed)；
- display 值为：inline-block、flex等；
- overflow 值为：hidden、auto、scroll；

## 清除浮动

浮动引起的问题：高度塌陷

解决办法：

1. 在浮动元素后加空的div并设置  clear:both;  缺点： 添加无意义标签使结构变差
2. 给父级元素设置BFC，例如 overflow:hidden ;
3. 给父级添加伪元素并设置 clear:both;

## 设置0.5px的边框

1. 利用缩放`transform: scale(0.5,0.5);`
2. 用阴影代替 box-shadow:0 0 0 0.5 #000   第三个参数是模糊度  第四个是阴影尺寸

## css3动画与js动画的区别

js：代码的复杂度高于CSS动画但动画控制能力很强，容易丢帧，没有兼容性问题。

css：代码相对简单，浏览器可以对动画进行优化，控制较弱。

# JS

## 数据类型

普通数据类型： Undefined、Null、Boolean、Number、String、Symbol

引用数据类型：Object（array 、function 、date 等）

## symbol遍历

- `let s = Symbol('描述');` 接受一个字符串作为参数，表示对 Symbol 的描述和区分
- Symbol 是一种类似于字符串的原始类型的值

- `Symbol`函数前不能使用`new`命令，否则会报错。

遍历：

`Object.getOwnPropertySymbols(obj)` 方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。

`Reflect.ownKeys(obj) `方法可以返回所有类型键名的数组，包括常规键名和 Symbol 键名。

## 数据类型检测的方式有哪些

typeof、instanceof、constructor、Object.prototype.toString.call().slice(8,-1)

## es6新特性

- let const、箭头函数、Promise、扩展运算符、解构赋值、严格相等运算符===、模板字符串'${}'、Set/Map数据结构、includes()、import/export default

## 中断promise链

中断promise链唯一方法是return padding状态的promise 
`return new Promise(() => {})`

### Set、Map

- Set：成员无序且不重复、可遍历。
  - 方法：add()、delete()、has()、clear()
  - 属性：size
  - 能重复add( { } 、[ ]) ，不能重复add(undefined、null、NaN)  尽管`null == undefined` 和 `NaN !== NaN`
- Map：可以以任意类型作为键，例如对象、数字等，可遍历。
  - 方法：set()、get()、has()、delete()、clear()
  - 属性：size
- WeakSet：成员都是弱引用类型的对象，可被垃圾回收机制回收，可用来保存dom节点。**不能遍历**。
- WeakMap：**键必须是对象**，键名是弱引用类型，可被垃圾回收机制回收。**不能遍历。**

## 事件、事件流、事件委托

### 事件

- DOM0级绑定事件监听：`el.onclick = function(){}`

- DOM2级绑定事件监听：`el.addEventListener("click", fn, false) `      #默认false冒泡

- 解绑事件监听 `el. removeEventListener("click", fn)`

- 事件对象event：当任何事件发生时，就会产生一个事件对象，就是程序中的event对象，我们只能在这个匿名函数中访问到这个event对象，在函数外面是访问不到的，同样我们也无法手动创建这个event对象

- 事件源：event.target：触发的元素

### 事件流

- 什么是事件流：元素触发事件时，该事件会在该元素与根节点之间的路径传播，路径所有经过的节点都会收到该事件，该传播过程叫DOM事件流，过程分为捕获和冒泡。

- `event.stopPropagation()` 阻止事件流。   #无论是冒泡还是捕获

- ``event.preventDefault()`阻止默认事件

### 事件委托(代理)

- **事件委托**：在父元素上设置监听函数，通过**事件冒泡**，父元素可监听到子元素上事件的触发，通过判断触发dom的类型做出不同的响应。
- 优点：大量节省内存占用，减少事件注册。   可实现当新增子元素时无需再次对其绑定
- 缺点：基于冒泡，对不冒泡的事件(mouseenter、mouseleave)不起作用。 层级多时可能会被某层阻止掉。把不该触发的邦上了事件

## 闭包

**闭包是指有权访问另一个函数作用域中变量的函数**

用途：外部能访问函数内部变量并且防止被垃圾回收

缺点：可能会造成内存泄漏

# Vue

## Vue的优点

- 双向数据绑定
- 组件化开发
- 视图和数据分离
- 虚拟DOM

## 谈谈Composition API

Composition API是Vue 3中的一个新特性，它是一种新的组织代码的方式，旨在解决Vue 2中复杂组件所带来的问题，使得组件的代码更加清晰易懂，更加易于维护。 Composition API的核心思想是将功能逻辑按照功能划分成一个个独立的函数，然后通过“组合”这些函数来实现组件的功能。这样做的好处是可以将组件逻辑分离出来，降低组件的复杂度，同时也可以更加灵活地组合不同的逻辑函数，实现更加精细化的功能。

## 双向数据绑定的原理

- vue通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。

- Object.defineProperty()缺点：只监听对象已有的属性，不能监听整个对象和新增的属性

## object.defineProperty和proxy的区别

- Vue 在实例初始化时遍历 data 中的所有属性，并使用 Object.defineProperty 把这些属性全部转为 getter/setter。这样当追踪数据发生变化时，setter 会被自动调用。
- 但是这样做有以下问题：
  - 添加或删除对象的属性时，Vue 检测不到。因为添加或删除的对象没有在初始化进行响应式处理，只能通过`$set` 来调用`Object.defineProperty()`处理。
- Proxy 有以下特点：
  - Proxy 直接代理整个对象而非对象属性，这样只需做一层代理就可以监听同级结构下的所有属性变化，包括新增属性和删除属性。

## 组件间的通信方式

- 父子之间通信：props/$emit、this.$ref、this.$children[0]、this.$parent
- 隔代通信：provide/inject、Vuex

## 父子组件生命周期的顺序

父创建 - 子1创建 - 子2创建 - 子1挂载完成 - 子2挂载完成 - 父挂载完成

## key的作用

- key是虚拟dom的标识，当数据发生改变时，vue会根据新数据生成新的虚拟dom通过key值和旧虚拟dom比较，如果不一样就，就将真实dom替换成新的虚拟dom，如果一样则用之前的真实dom，如果未找到对应的key值，就会添加一个真实的dom。

为什么不建议用index作为key?

- 使用index 作为 key值，如果逆序添加或删除，所有虚拟dom和key值就发生了改变，这样就可能带来不必要的更新，性能会降低。

## Vuex

State 、Mutation （同步）、Action （异步）、getters（类似computed）

## Computed、Watch 的区别

Computed：支持缓存，不支持异步，只有依赖的数据发生了变化，才会重新计算

Watch ：它不支持缓存，支持异步监听，数据变化时，它就会触发相应的操作，内部有两个参数（immediate，deep）

## slot插槽

默认插槽、具名插槽、作用域插槽

作用域插槽可以将子组件内部的数据传递给父组件，让父组件根据子组件的传递过来的数据决定如何渲染该插槽。

```html
//子组件中（具名+默认）
<slot :={user,arr}></slot>              //:=写法等同于 :user="user" :arr="arr" 对象中的写出来
<slot name="other" :={user,arr}></slot>  //具名作用域插槽

//父组件中
<Child>
  <template #default="slotProps">  //自己定义默认插槽接收的数据的名字
    {{slotProps.user.age}}  and  {{slotProps.arr[2]}}
  </template>
	
  <template #other="wzk"> 
      {{wzk.user.age}}  and  {{wzk.arr[2]}}
  </template>
</Child>
```

## keep-alive组件

- 缓存页面，保存组件的状态，用keep-alive包裹的组件在切换时不会进行销毁
- keep-alive有 两个独有的生命周期钩子函数**activated**、**deactivated**

```html
//将缓存 组件名name 为 a 或者 b 的组件，结合动态组件使用
<keep-alive include='a,b'>
    <router-view/>
</keep-alive>
或
<keep-alive>
    <router-view v-if="$route.meta.keepAlive"></router-view>//路由中设置keepAlive:true
</keep-alive>
```

## 事件修饰符及其作用

- `.stop` ：防止事件冒泡
- `.capture`：事件捕获
- `.prevent`：阻止默认事件
- `.self`：只会触发自己范围内的事件，不包含子元素；
- `.once` ：只会触发一次
- `.lazy`：输入框失焦时才会更新v-model的值

## $nextTick

在下一轮视图更新过后再执行，会返回一个 `Promise` 对象

应用：有时候可能遇到这样的情况，DOM1的数据发生了变化，而DOM2需要从DOM1中获取数据，那这时就会发现DOM2的视图并没有更新，这时就需要用到了`nextTick`了。

```js
// 例子
{{num}}
for(let i=0; i<100000; i++){
    num = i
}
//如果没有 nextTick 更新机制，那么 num 每次更新值都会触发视图更新(上面这段代码也就是会更新10万次视图)，有了nextTick机制，只需要更新一次，所以nextTick本质是一种优化策略
```



## 单页应用与多页应用的区别

- SPA单页面应用，指整个应用只有一个完整的页面。点击导航不会刷新页面，仅仅刷新局部资源，就是切换相关组件。
  - 缺点：不利于SEO  =>   解决方案：SSR  服务端解析、浏览器只负责渲染
- MPA多页面应用 ，指有多个独立页面的应用。多页应用跳转，需要整页资源刷新。

## 自定义指令（directive）

应用：自定义鼠标聚焦、自定义指令实现图片懒加载

```js
// 注册一个全局自定义指令 `v-focus`
app.directive('focus', {     //全局directive、局部指令directives
  // 当被绑定的元素挂载时触发……
  mounted(el) {
    // 聚焦元素
    el.focus()
  }
})

使用：<input v-focus />
```

## React 和 Vue 它们的异同

相似之处：

- 都使用了虚拟DOM提高重绘性能；
- 都鼓励组件化应用，将应用分拆成一个个功能明确的模块，提高复用性。

不同之处：

- Vue默认支持数据双向绑定，而React一直提倡单向数据流 
- Vue鼓励写近似常规HTML的模板。React推荐你所有的模板用JSX书写

## 导航守卫有哪些

- 全局前置/后置钩子：beforeEach、afterEach
- 路由独享的守卫：beforeEnter
- 组件内的守卫：beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave

# 计算机网络

## OSI 七层模型

物理层、数据链路层、网络层、传输层、会话层、表示层、应用层

## TCP/IP 五层模型

应用层：TFTP，HTTP，SNMP，FTP，SMTP，DNS，Telnet
传输层：TCP，UDP
网络层：IP，ICMP，RIP，OSPF，BGP，IGMP
数据链路层：SLIP，CSLIP，PPP，ARP，RARP，MTU
物理层

## TCP、UDP的区别

- TCP(传输控制协议)是传输层的一个协议，它负责在数据传送之前将它们**分割为数据包**，然后在它们**到达的时候**将它们**重组**。

- 区别：

  - TCP是面向`链接`的，而UDP是面向无连接的。
  - TCP仅支持`单播传输`，UDP 提供了单播，多播，广播的功能。
  - TCP的三次握手保证了连接的`可靠性`; UDP是无连接的、不可靠的一种数据传输协议，首先不可靠性体现在无连接上，通信都不需要建立连接，对接收到的数据也不发送确认信号，发送端不知道数据是否会正确接收。
  - UDP的`头部开销`比TCP的更小，数据`传输速率更高`，`实时性更好`。
- 引用场景：TCP：文件传输             UDP：游戏、直播、视频

## TCP如何实现数据的可靠性

- TCP通过**确认应答、超时重传、拥塞控制**等机制来保证可靠性。

## TCP的三次握手

**三次握手的本质是确认通信双方收发数据的能力是否正常**

1. `第一次握手`：我向你发起SYN报文，并指明自己的初始化序列号ISN。
2. `第二次握手`：你收到SYN报文之后，会以你的 SYN 报文作为应答，你为了确认收到我的 SYN，会将我的 ISN+1作为ACK的值并指定自己的ISN。
3. `第三次握手`：我收到 SYN 报文之后，会发送一个 ACK 报文，值为你的ISN+1。服务器收到 ACK 报文之后，我们就建立起好了连接。

**第三次握手是可以携带数据的，前两次握手是不可以携带数据的,因为第三次只要服务端就接收到了就已经是链接成功了**

为什么是3次握手而不是2次或者4次？

- 2次相当于没有第3次的向你返回一个ACK确认收到的信息，无法确定你发的包我能收到
- 会有这样的情况，我发送连接请求后因为网络原因断开连接了，而你不知道我断开了还依旧发送数据，这样导性能致资源的浪费
- 3次就能保证有效连接，4次就没必要了，会降低传输效率

## 四次挥手

1. `第一次挥手`：当我的数据都传输完成后，我就会发送一个 FIN 报文，报文中会指定一个序列号seq。
2. `第二次挥手`：你收到 FIN 之后，会发送 ACK 报文，且把我的序列号值 +1 作为 ACK 报文确认号值，表明已经收到我的报文了。此时你处于**关闭等待状态**，而不是立马给我发FIN报文，这个状态还要持续一段时间，因为你可能还有数据没发完。
3. `第三次挥手`：你将剩下数据发送完毕后，发送 FIN 和 ACK 报文，且指定一个你的序列号seq。
4. `第四次挥手`：我收到FIN报文后，向你发出ACK报文。我发出确认报文后不是立马释放TCP连接，而是要经过2MSL(最长报文段寿命的2倍时长)后才释放TCP连接。而你一旦收到我发出的确认报文就会立马释放TCP连接，所以服务端结束TCP连接的时间要比客户端早一些。

为什么是4次挥手而不是3次

- 我发出连接释放报文时只能保证我没有数据发了，你还有没有数据发我是不知道的。
- 而你收到我的释放报文后只能先回复我一个确认报文来告诉我你已经收到我的释放报文了，但你还有一些数据没发完，等这些数据发完了你才能给我发连接释放报文

为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接？

- 为了确保你收到了第四次挥手的报文，如果第四次挥手的报文丢失，你没收到确认ack报文就会重发第三次挥手的报文，这样报文一去一回最长时间就是2MSL，所以我需要等这么长时间来确认你确实已经收到了。

##  TCP的重传机制

- TCP会根据**时间和确认信息**来重传其认为已丢失的包。
- TCP在发送一个数据之后，就开启一个定时器，若是在这个时间内没有收到发送数据的ACK确认报文，则对该报文进行重传，在达到一定次数还没有成功时放弃并发送一个复位信号。

## TCP的拥塞控制机制

- TCP采用大小可变的**滑动窗口**进行流量控制
- 当一个连接建立时，连接的每一端分配一个缓冲区来保存输入的数据，并将缓冲区的大小发送给另一端。
- 如果发送方操作的速度快于接收方，接收到的数据最终将充满接收方的缓冲区，导致接收方通告一个零窗口 。发送方收到一个零窗口通告时，必须停止发送，直到接收方重新通告一个正的窗口。

## HTTP 与 HTTPS 的区别

- HTTP 是服务器与浏览器传输超文本数据的一种规范，负责两者之间的通信。
- 区别：http是明文传输        https经过认证和加密的传输

## HTTPS的工作原理

1. 客户端先向服务端发起请求，请求带了客户端支持的加密算法
2. 服务端收到请求后将数字证书返回给客户端
3. 客户端从内置的证书列表中查该数字证书对应的机构是否可信。未查到：发出警告；查到：取出该机构颁发的公钥。
4. 客户端用机构颁发的公钥解密得到服务端公钥
5. 客户端生成会话密钥，用服务端公钥加密会话密钥再发送给服务端
6. 服务端用私钥解密拿到会话密钥
7. 以后双方通信前，就使用这个密钥对数据进行加密后再传输

总结：HTTPS 协议使用了非对称加密 + 对称加密的方式，即利用了非对称加密安全性高的特点，又利用了对称加密速度快，效率高的好处

## 数字证书和数字签名

- 数字证书：包含由CA机构加密发信方公钥，保证公钥不被他人篡改
- 数字签名：发信方用私钥加密哈希摘要形成数字签名，保证内容不被篡改

## 常用HTTP状态码

| 状态码 |                         表示                          |
| :----: | :---------------------------------------------------: |
|  1xx   |                       正在处理                        |
|  200   |                   服务器正常处理了                    |
|  204   |         服务器正常处理了，但是没有返回的内容          |
|  301   | 资源被永久移动，返回信息包括新的url，浏览器自动重定向 |
|  302   |                    资源被临时移动                     |
|  304   |          资源未改变，可直接使用缓存中的数据           |
|  400   |        客户端请求的语法有错误，服务器无法理解         |
|  401   |                     没有权限访问                      |
|  403   |                       拒绝请求                        |
|  404   |                      没找到资源                       |
|  5xx   |                    服务器内部错误                     |

## HTTP1.0、1.1、2.0

- 1.0和1.1的区别
  - **新增请求方法**：1.1 还新增了很多**请求方法**，如 PUT(提交)、DELETE、HEAD(只响应请求头)、OPTIONS
  - 长连接：1个tcp连接可以传送多个请求和响应，减少了建立和关闭连接的延迟和消耗。

- 1.1和2.0的区别
  - **多路复用**：1.版本浏览器对一个域名下最大TCP连接数为6。2.0版本客户端和服务器都可以同时发送多个请求或回应，而且**不用按照顺序一一发送**，这样就避免了"队头堵塞"的问题
  - **二进制协议和数据流**：1.1报文的头信息必须是文本，2.0头信息和数据体都是二进制，并且统称为"帧"， 2.0 的数据包可以是不按顺序发送的，同一个连接里面连续的数据流，可以属于不同的请求。这样提高了通信的效率。
  - **服务端推送:**HTTP2 引入服务器推送，允许服务端推送资源给客户端

## 常见的HTTP请求头和响应头

**HTTP Request Header 常见的请求头：**

- Accept:浏览器能够处理的内容类型
- Accept-Charset:浏览器能够显示的字符集
- Accept-Encoding：浏览器能够处理的压缩编码
- Accept-Language：浏览器当前设置的语言
- Cookie：当前页面设置的任何Cookie
- Host：发出请求的页面所在的域
- Referer：发出请求的页面的URL
- User-Agent：浏览器的用户代理字符串

**HTTP Responses Header 常见的响应头：**

- Date：表示消息发送的时间
- server:服务器名称
- Cache-Control：控制HTTP缓存
- content-type:告诉客户端实际返回的内容的内容类型。

## 常见的 Content-Type 属性值

1. application/x-www-form-urlencoded：浏览器的原生 form 表单
2. multipart/form-data：该种方式也是一个常见的 POST 提交方式，通常表单上传文件时使用该种方式。
3. application/json：服务器消息主体是序列化后的 JSON 字符串。
4. text/xml：该种方式主要用来提交 XML 格式的数据。

## HTTP请求和响应报文的组成？

- 响应报⽂有4部分组成:响应头、响应体、响应行、空行
- 请应报⽂有4部分组成: 请求头、请求体、请求行、空行

## POST和GET的区别

| 区别     |                             Get                              |                             POST                             |
| -------- | :----------------------------------------------------------: | :----------------------------------------------------------: |
| 应用场景 | 一般对服务器资源不会产生影响的场景，比如说请求一个网页的资源。 | 一般用于对服务器资源会产生影响的情景，比如注册用户这一类的操作。 |
| 缓存     |                 浏览器一般会对 Get 请求缓存                  |                     很少对 Post 请求缓存                     |
| 安全性   | 可以将请求的参数放入 url 中向服务器发送，因为请求的 url 会被保留在历史记录中，安全性相对较低 |                       参数放在请求体中                       |
| 请求长度 |          浏览器对url有长度限制，所以对get请求有影响          |                            无限制                            |
| 编码方式 |                         只能url编码                          |           有多种，如multipart/form-data，text/xml            |

## Session、Cookie和Token的主要区别

- HTTP协议本身是无状态的。什么是无状态呢，即服务器无法判断用户身份。
- **什么是cookie？**
  - cookie是保存在浏览器上的小文件，包含用户相关的信息。客户端向服务器发起请求，如果服务器需要记录该用户状态，就给客户端颁发一个Cookie。客户端会把Cookie保存起来。当浏览器再请求该网站时，请求头中会自带Cookie字段。服务器检查该字段，以此来辨认用户身份。
  - 字段：Max-Age、Domain、Path、HttpOnly、Secure
- **什么是session？**
  - session是服务器设定的。session是依赖Cookie实现的。浏览器请求中的 cookie 内含 sessionid ，服务器根据 sessionid 获取信息，然后确定用户身份。

- **cookie与session区别**
  - 存储位置与安全性：cookie数据存放在客户端上，安全性较差，session在服务器上，安全性相对更高；
  - 存储空间：单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie，session无此限制
  - 占用服务器资源：session保存在服务器上，当用户增多，占用服务器性能

- **什么是Token**
  - Token的定义：Token是服务端生成的一串字符串，当作客户端进行请求的一个令牌，当第一次登录后服务端会生成一个Token便将此Token返回给客户端，以后客户端只需带上这个Token前来请求数据即可
  - 使用Token的目的：Token的目的是为了减轻服务器的压力，减少频繁的查询数据库

## （重点）从输入URL到页面加载的全过程

1. **URL解析**：首先在浏览器中输入URL
2. **缓存判断：**浏览器会判断所请求的资源是否在缓存里，如果请求的资源在缓存里并且没有失效，那么就直接使用，没有则再判断本地是否有该域名的 IP 地址的缓存，如果有就向服务器发起新的请求。
3. **DNS解析获取IP：**如果没有就向DNS服务器发起请求获取IP地址（`DNS服务器是基于UDP的，因此会用到UDP协议`）然后开始与服务器通过三次握手建立TCP链接。
4. **建立TCP连接：**三次握手
5. **发送HTTP请求：**其中请求的报文会在TCP第三次握手的时候发送给服务器
6. **服务器响应请求并返回结果**：服务器收到请求后响应对应的资源
7. **释放TCP连接**：然后通过四次挥手释放TCP链接
8. **页面渲染：**浏览器拿资源后首先会根据 html 文件构建 DOM 树，根据 css 文件构建 CSSOM 树，当 DOM 树和 CSSOM 树建立好后，再根据它们来构建渲染树。渲染树构建好后，会根据渲染树来进行布局。布局完成后，最后使用浏览器的 UI 接口对页面进行绘制。这个时候整个页面就显示出来了。

# 浏览器

## XSS和CRSF攻击

- xss：跨站脚本攻击，攻击者在网页开发阶段注入恶意脚本，用户加载执行恶意程序，从而盗取用户的信息如 cookie 等。
- 防御手段: js-xss过滤、 输入输出检查、给cookie设置HttpOnly字段值为true
- CRSF：跨站点请求伪造。攻击者盗用你的身份，以你的名义发送恶意请求。  (攻击者诱导用户进入一个第三方网站，然后该网站向被攻击网站发送跨站请求。如果用户在被攻击网站中保存了登录状态，那么攻击者就可以利用这个登录状态，绕过后台的用户验证，冒充用户向服务器执行一些操作。)
- 防御手段：
  - 验证码
  - 进行同源检测：服务器根据 http 请求头中 origin 或者 referer 信息来判断请求是否为允许访问的站点
  - 添加token并验证：服务器向用户返回一个 Token ，当网站再次发起请求时加 token。
  - 在http头中添加自定义属性并验证

## 进程与线程

1. 进程与线程的概念：进程放在应用上来说就代表了一个程序。线程是程序执行中一个顺序控制流程。
2. 进程是资源分配的最小单位，线程是CPU调度的最小单位。
3. 进程和线程有以下四个特点：
   1. 进程中的任意一线程执行出错，都会导致整个进程的崩溃。
   2. 线程之间共享进程中的数据。
   3. 当一个进程关闭之后，操作系统会回收进程所占用的内存
   4. 进程之间的内容相互隔离。
4. 进程和线程的区别
   1. 进程可以看做独立应用，线程不能
   2. 通信方面：线程之间共享进程中的数据。
   3. 开销：进程切换比线程切换的开销要大。

## (重点)浏览器(http)的缓存机制

**浏览器缓存的全过程：**

1. 浏览器每次发网页起请求，都会先判断请求头是否有缓存标识，如果有就会先在浏览器缓存中查找该请求的资源
2. 缓存分为强缓存和协商缓存，浏览器根据缓存标识判断是强缓存还是协商缓存
3. 若缓存标识有`Cache-Control`字段且没有设置`no-cache`且没过期就为强缓存则直接从本地读取资源。
4. 否则就为协商缓存，浏览器向服务器发送带有 **Etag** 和 **Last-Modified** 的请求；
5. 服务器收到请求后，优先根据 Etag 的值判断被请求的文件有没有做修改，Etag 值一致则没有修改，返回 304；如果不一致则有改动，直接返回新的资源文件带上新的 Etag 值并返回 200；
6. 如果服务器收到的请求没有 Etag 值，则将 last-modified  和被请求文件的最后修改时间做比对，一致则返回 304；不一致则返回新的资源文件和新的 last-modified 并返回 200；
7. 浏览器每次向服务器拿到新资源后，都会根据响应头的缓存标识，决定是否缓存资源；

**协商缓存和强缓存：**

- 强缓存：
  - Cache-Control 的优先级要高于 Expires。
  - `Cache-Control`可设置的字段：
    - `max-age=`：设置缓存的最大有效期，单位为秒；
    - `private`：资源只能被用户浏览器缓存，不允许任何代理服务器缓存。
    - `no-cache` 是指没有强缓存，但是会有协商缓存；
    - `no-store` 是指不使用任何缓存，每次请求都直接从服务器获取资源。
- 协商缓存：
  -  Etag 的优先级要高于Last-Modified
  -  Last-Modified 标注的最后修改时间只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，那么文件已将改变了但是 Last-Modified 却没有改变，这样会造成缓存命中的不准确。
  -  **Etag** 可以准确判断文件文件是否被修改
  -  If-None-Match：Etag 和If-Modified-Since：Last-Modified

**使用浏览器缓存，有以下优点：**

- 减少了服务器的负担，提高了网站的性能
- 加快了客户端网页的加载速度

## （重点）浏览器渲染原理

1. 浏览器的渲染过程：DOM + CSSOM => 渲染树=> 布局 => 绘制
   1. 首先解析收到的文档，根据文档节点构建一棵 DOM 树
   2. 然后对 CSS 进行解析，生成 CSSOM 规则树。
   3. 根据 DOM 树和 CSSOM 规则树构建渲染树。
   4. 根据渲染树来进行布局。这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。
   5. 布局阶段结束后是绘制阶段，浏览器会遍历渲染树并调用自带的 UI 基础组件将它们的内容绘制在屏幕上。

## 浏览器同源策略及跨域

同源策是浏览器的一个安全机制，略限制了端和端之间的交互。同源指的是：**协议**、**端口号**、**域名**必须一致。

**为什么`script`标签不会受到同源策略的影响？**

​			脚本的来源取决于脚本所嵌入的资源的来源，比如说访问A主机的当前HTML文件中有一个script标签，这个script标签的src属性请求了一个js脚本，**因为这个脚本是由A主机的HTML文件的嵌入的script标签发起请求获取的**，因此这个脚本的来源是属于A主机的。

**如何解决跨域**

- Cors（Access-Control-Allow-Origin）
- JSonp
- Nginx
- 中间服务器代理（设置一个同源的代理服务器，让代理服务器请求跨域的资源  然后再返回给客户端）

## (重点)事件循环机制的理解

1. 为什么会有事件循环？

   - 因为 js 是单线程运行的。
2. 什么是事件循环？
   - 当执行栈遇到异步任务时，js 引擎会将这个任务放交给异步处理模块，然后继续执行同步代码。当异步任务达到触发条件时，会将相应回调压入任务队列中等待执行。而事件循环就是循环执行任务队列。
3. 任务队列

   1. 宏任务：定时器、ajax、读取文件
   2. 微任务：promise.then()
4. 当前宏任务的执行顺序如下所示：

   - 同步代码 
   - process.nextTick(同步任务执行结束)        
   - 微任务
   - 下一个宏任务
   - setImmediate(当前循环执行结束)

## 垃圾回收机制

- **原理：**垃圾收集器会定期（周期性）找出那些不在继续使用的变量， 然后释放其内存。
- ‌垃圾回收机制只会自动回收局部变量，全局变量不会被回收（直到网页关闭）。
- 垃圾回收策略：
  - 标记清除(常用) ：当变量进入环境时，将变量标记"进入环境"，当变量离开环境时，标记为："离开环境"。被标记为："离开环境"的变量视为准备回收的对象。
    - 缺点：容易产生内存碎片。
  - 引用计数：基本原理就是变量被引用一次则加1，取消引用一次-1，当这个引用计数为0时，被视为准备回收的对象。
    - 缺点：如果多个变量间产生循环引用，则这几个对象均无法回收
- 哪些操作会造成内存泄漏？
  - 意外的全局变量引起内存泄漏
  - 闭包引起的内存泄漏
  - 被遗忘的定时器或回调

# 其他

## 性能优化

构建上的优化

- 代码压缩 - webpack
- 路由懒加载、图片懒加载（vue-lazyload）
- 图片使用webp格式，体积小请求快
- HTTP缓存（强缓存，协商缓存）
- 第三方资源按需引入，或者使用CDN的方式引入

渲染优化

- 异步加载JS文件 - defer - async
- 减少重排重绘
- 减少通配符和标签选择器，多用类选择器

代码优化

- 提高代码的复用性，不写冗余的代码
- 节流防抖等
- 组件化开发

## webpack的Loader和Plugin的不同

**不同的作用:**

- **Loader**直译为"加载器"。Webpack将一切文件视为模块，但是webpack原生是只能解析js文件，如果想将其他文件也打包的话，就会用到`loader`。 所以Loader的作用是让webpack拥有了加载和解析*非JavaScript文件*的能力。
- **Plugin**直译为"插件"。Plugin可以扩展webpack的功能，让webpack具有更多的灵活性。 在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。

**不同的用法:**

- **Loader**在`module.rules`中配置，也就是说他作为模块的解析规则而存在。 类型为数组，每一项都是一个`Object`，里面描述了对于什么类型的文件（`test`），使用什么加载(`loader`)和使用的参数（`options`）
- **Plugin**在`plugins`中单独配置。 类型为数组，每一项是一个`plugin`的实例，参数都通过构造函数传入。

## ES6模块和CommonJS的区别

- CommonJS 模块输出的是一个值的浅拷贝，ES6 模块输出的是值的引用（ES6 模块输入的变量是活的）。
-  CommonJS 加载的是一个对象（即`module.exports`导出的对象），该对象只有在脚本运行完才会生成。这种加载称为“运行时加载”。
- ES6 模块不是对象，而是通过`export`命令显式指定输出的代码，`import`时指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载”。

## 栈和堆的区别

堆与栈的区别有：

1、栈由系统自动分配，而堆是人为申请开辟；

2、栈获得的空间较小，而堆获得的空间较大；

3、栈由系统自动分配，速度较快，而堆一般速度比较慢；

4、栈是连续的空间，而堆是不连续的空间。

## jwt

Session 方式来存储用户 id，一开始用户的 Session 只会存储在一台服务器上。对于有多个子域名的站点，每个子域名至少会对应一台不同的服务器，例如：www.taobao.com，nv.taobao.com，nz.taobao.com，login.taobao.com。所以如果要实现在login.taobao.com登录后，在其他的子域名下依然可以取到 Session，这要求我们在多台服务器上同步 Session。使用 JWT 的方式则没有这个问题的存在，因为用户的状态已经被传送到了客户端。